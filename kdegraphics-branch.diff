Index: kpdf/core/generator_pdf/generator_pdf.cpp
===================================================================
--- kpdf/core/generator_pdf/generator_pdf.cpp	(.../tags/KDE/3.5.8/kdegraphics)	(wersja 734657)
+++ kpdf/core/generator_pdf/generator_pdf.cpp	(.../branches/KDE/3.5/kdegraphics)	(wersja 734657)
@@ -152,7 +152,7 @@
         }
 
         // 2. reopen the document using the password
-        GString * pwd2 = new GString( password.data() );
+        GString * pwd2 = new GString( QString::fromLocal8Bit(password.data()).latin1() );
             delete pdfdoc;
         pdfdoc = new PDFDoc( new GString( QFile::encodeName( filePath ) ), pwd2, pwd2 );
             delete pwd2;
Index: kpdf/xpdf/xpdf/Stream.cc
===================================================================
--- kpdf/xpdf/xpdf/Stream.cc	(.../tags/KDE/3.5.8/kdegraphics)	(wersja 734657)
+++ kpdf/xpdf/xpdf/Stream.cc	(.../branches/KDE/3.5/kdegraphics)	(wersja 734657)
@@ -1245,23 +1245,30 @@
   columns = columnsA;
   if (columns < 1) {
     columns = 1;
+  } else if (columns > INT_MAX - 2) {
+    columns = INT_MAX - 2;
   }
-  if (columns + 4 <= 0) {
-    columns = INT_MAX - 4;
-  }
   rows = rowsA;
   endOfBlock = endOfBlockA;
   black = blackA;
-  refLine = (short *)gmallocn(columns + 3, sizeof(short));
-  codingLine = (short *)gmallocn(columns + 2, sizeof(short));
+  // 0 <= codingLine[0] < codingLine[1] < ... < codingLine[n] = columns
+  // ---> max codingLine size = columns + 1
+  // refLine has one extra guard entry at the end
+  // ---> max refLine size = columns + 2
+  codingLine = (int *)gmallocn_checkoverflow(columns + 1, sizeof(int));
+  refLine = (int *)gmallocn_checkoverflow(columns + 2, sizeof(int));
 
-  eof = gFalse;
+  if (codingLine != NULL && refLine != NULL) {
+    eof = gFalse;
+    codingLine[0] = columns;
+  } else {
+    eof = gTrue;
+  }
   row = 0;
   nextLine2D = encoding < 0;
   inputBits = 0;
-  codingLine[0] = 0;
-  codingLine[1] = refLine[2] = columns;
-  a0 = 1;
+  a0i = 0;
+  outputBits = 0;
 
   buf = EOF;
 }
@@ -1276,13 +1283,18 @@
   short code1;
 
   str->reset();
-  eof = gFalse;
+
+  if (codingLine != NULL && refLine != NULL) {
+    eof = gFalse;
+    codingLine[0] = columns;
+  } else {
+    eof = gTrue;
+  }
   row = 0;
   nextLine2D = encoding < 0;
   inputBits = 0;
-  codingLine[0] = 0;
-  codingLine[1] = columns;
-  a0 = 1;
+  a0i = 0;
+  outputBits = 0;
   buf = EOF;
 
   // skip any initial zero bits and end-of-line marker, and get the 2D
@@ -1299,211 +1311,230 @@
   }
 }
 
+inline void CCITTFaxStream::addPixels(int a1, int blackPixels) {
+  if (a1 > codingLine[a0i]) {
+    if (a1 > columns) {
+      error(getPos(), "CCITTFax row is wrong length (%d)", a1);
+      err = gTrue;
+      a1 = columns;
+    }
+    if ((a0i & 1) ^ blackPixels) {
+      ++a0i;
+    }
+    codingLine[a0i] = a1;
+  }
+}
+
+inline void CCITTFaxStream::addPixelsNeg(int a1, int blackPixels) {
+  if (a1 > codingLine[a0i]) {
+    if (a1 > columns) {
+      error(getPos(), "CCITTFax row is wrong length (%d)", a1);
+      err = gTrue;
+      a1 = columns;
+    }
+    if ((a0i & 1) ^ blackPixels) {
+      ++a0i;
+    }
+    codingLine[a0i] = a1;
+  } else if (a1 < codingLine[a0i]) {
+    if (a1 < 0) {
+      error(getPos(), "Invalid CCITTFax code");
+      err = gTrue;
+      a1 = 0;
+    }
+    while (a0i > 0 && a1 <= codingLine[a0i - 1]) {
+      --a0i;
+    }
+    codingLine[a0i] = a1;
+  }
+}
+
 int CCITTFaxStream::lookChar() {
   short code1, code2, code3;
-  int a0New;
-  GBool err, gotEOL;
-  int ret;
-  int bits, i;
+  int b1i, blackPixels, i, bits;
+  GBool gotEOL;
 
-  // if at eof just return EOF
-  if (eof && codingLine[a0] >= columns) {
-    return EOF;
+  if (buf != EOF) {
+    return buf;
   }
 
   // read the next row
-  err = gFalse;
-  if (codingLine[a0] >= columns) {
+  if (outputBits == 0) {
 
+    // if at eof just return EOF
+    if (eof) {
+      return EOF;
+    }
+
+    err = gFalse;
+
     // 2-D encoding
     if (nextLine2D) {
-      // state:
-      //   a0New = current position in coding line (0 <= a0New <= columns)
-      //   codingLine[a0] = last change in coding line
-      //                    (black-to-white if a0 is even,
-      //                     white-to-black if a0 is odd)
-      //   refLine[b1] = next change in reference line of opposite color
-      //                 to a0
-      // invariants:
-      //   0 <= codingLine[a0] <= a0New
-      //           <= refLine[b1] <= refLine[b1+1] <= columns
-      //   0 <= a0 <= columns+1
-      //   refLine[0] = 0
-      //   refLine[n] = refLine[n+1] = columns
-      //     -- for some 1 <= n <= columns+1
-      // end condition:
-      //   0 = codingLine[0] <= codingLine[1] < codingLine[2] < ...
-      //     < codingLine[n-1] < codingLine[n] = columns
-      //     -- where 1 <= n <= columns+1
       for (i = 0; codingLine[i] < columns; ++i) {
 	refLine[i] = codingLine[i];
       }
-      refLine[i] = refLine[i + 1] = columns;
-      b1 = 1;
-      a0New = codingLine[a0 = 0] = 0;
-      do {
+      refLine[i++] = columns;
+      refLine[i] = columns;
+      codingLine[0] = 0;
+      a0i = 0;
+      b1i = 0;
+      blackPixels = 0;
+      // invariant:
+      // refLine[b1i-1] <= codingLine[a0i] < refLine[b1i] < refLine[b1i+1]
+      //                                                             <= columns
+      // exception at left edge:
+      //   codingLine[a0i = 0] = refLine[b1i = 0] = 0 is possible
+      // exception at right edge:
+      //   refLine[b1i] = refLine[b1i+1] = columns is possible
+      while (codingLine[a0i] < columns) {
 	code1 = getTwoDimCode();
 	switch (code1) {
 	case twoDimPass:
-	  if (refLine[b1] < columns) {
-	    a0New = refLine[b1 + 1];
-	    b1 += 2;
+	  addPixels(refLine[b1i + 1], blackPixels);
+	  if (refLine[b1i + 1] < columns) {
+	    b1i += 2;
 	  }
 	  break;
 	case twoDimHoriz:
-	  if ((a0 & 1) == 0) {
-	    code1 = code2 = 0;
+	  code1 = code2 = 0;
+	  if (blackPixels) {
 	    do {
-	      code1 += code3 = getWhiteCode();
+	      code1 += code3 = getBlackCode();
 	    } while (code3 >= 64);
 	    do {
-	      code2 += code3 = getBlackCode();
+	      code2 += code3 = getWhiteCode();
 	    } while (code3 >= 64);
 	  } else {
-	    code1 = code2 = 0;
 	    do {
-	      code1 += code3 = getBlackCode();
+	      code1 += code3 = getWhiteCode();
 	    } while (code3 >= 64);
 	    do {
-	      code2 += code3 = getWhiteCode();
+	      code2 += code3 = getBlackCode();
 	    } while (code3 >= 64);
 	  }
-	  if (code1 > 0 || code2 > 0) {
-	    if (a0New + code1 <= columns) {
-	      codingLine[a0 + 1] = a0New + code1;
-	    } else {
-	      codingLine[a0 + 1] = columns;
+	  addPixels(codingLine[a0i] + code1, blackPixels);
+	  if (codingLine[a0i] < columns) {
+	    addPixels(codingLine[a0i] + code2, blackPixels ^ 1);
+	  }
+	  while (refLine[b1i] <= codingLine[a0i] && refLine[b1i] < columns) {
+	    b1i += 2;
+	  }
+	  break;
+	case twoDimVertR3:
+	  addPixels(refLine[b1i] + 3, blackPixels);
+	  blackPixels ^= 1;
+	  if (codingLine[a0i] < columns) {
+	    ++b1i;
+	    while (refLine[b1i] <= codingLine[a0i] && refLine[b1i] < columns) {
+	      b1i += 2;
 	    }
-	    ++a0;
-	    if (codingLine[a0] + code2 <= columns) {
-	      codingLine[a0 + 1] = codingLine[a0] + code2;
-	    } else {
-	      codingLine[a0 + 1] = columns;
-	    }
-	    ++a0;
-	    a0New = codingLine[a0];
-	    while (refLine[b1] <= a0New && refLine[b1] < columns) {
-	      b1 += 2;
-	    }
 	  }
 	  break;
-	case twoDimVert0:
-	  if (refLine[b1] < columns) {
-	    a0New = codingLine[++a0] = refLine[b1];
-	    ++b1;
-	    while (refLine[b1] <= a0New && refLine[b1] < columns) {
-	      b1 += 2;
+	case twoDimVertR2:
+	  addPixels(refLine[b1i] + 2, blackPixels);
+	  blackPixels ^= 1;
+	  if (codingLine[a0i] < columns) {
+	    ++b1i;
+	    while (refLine[b1i] <= codingLine[a0i] && refLine[b1i] < columns) {
+	      b1i += 2;
 	    }
-	  } else {
-	    a0New = codingLine[++a0] = columns;
 	  }
 	  break;
 	case twoDimVertR1:
-	  if (refLine[b1] + 1 < columns) {
-	    a0New = codingLine[++a0] = refLine[b1] + 1;
-	    ++b1;
-	    while (refLine[b1] <= a0New && refLine[b1] < columns) {
-	      b1 += 2;
+	  addPixels(refLine[b1i] + 1, blackPixels);
+	  blackPixels ^= 1;
+	  if (codingLine[a0i] < columns) {
+	    ++b1i;
+	    while (refLine[b1i] <= codingLine[a0i] && refLine[b1i] < columns) {
+	      b1i += 2;
 	    }
-	  } else {
-	    a0New = codingLine[++a0] = columns;
 	  }
 	  break;
-	case twoDimVertL1:
-	  if (refLine[b1] - 1 > a0New || (a0 == 0 && refLine[b1] == 1)) {
-	    a0New = codingLine[++a0] = refLine[b1] - 1;
-	    --b1;
-	    while (refLine[b1] <= a0New && refLine[b1] < columns) {
-	      b1 += 2;
+	case twoDimVert0:
+	  addPixels(refLine[b1i], blackPixels);
+	  blackPixels ^= 1;
+	  if (codingLine[a0i] < columns) {
+	    ++b1i;
+	    while (refLine[b1i] <= codingLine[a0i] && refLine[b1i] < columns) {
+	      b1i += 2;
 	    }
 	  }
 	  break;
-	case twoDimVertR2:
-	  if (refLine[b1] + 2 < columns) {
-	    a0New = codingLine[++a0] = refLine[b1] + 2;
-	    ++b1;
-	    while (refLine[b1] <= a0New && refLine[b1] < columns) {
-	      b1 += 2;
+	case twoDimVertL3:
+	  addPixelsNeg(refLine[b1i] - 3, blackPixels);
+	  blackPixels ^= 1;
+	  if (codingLine[a0i] < columns) {
+	    if (b1i > 0) {
+	      --b1i;
+	    } else {
+	      ++b1i;
 	    }
-	  } else {
-	    a0New = codingLine[++a0] = columns;
+	    while (refLine[b1i] <= codingLine[a0i] && refLine[b1i] < columns) {
+	      b1i += 2;
+	    }
 	  }
 	  break;
 	case twoDimVertL2:
-	  if (refLine[b1] - 2 > a0New || (a0 == 0 && refLine[b1] == 2)) {
-	    a0New = codingLine[++a0] = refLine[b1] - 2;
-	    --b1;
-	    while (refLine[b1] <= a0New && refLine[b1] < columns) {
-	      b1 += 2;
+	  addPixelsNeg(refLine[b1i] - 2, blackPixels);
+	  blackPixels ^= 1;
+	  if (codingLine[a0i] < columns) {
+	    if (b1i > 0) {
+	      --b1i;
+	    } else {
+	      ++b1i;
 	    }
-	  }
-	  break;
-	case twoDimVertR3:
-	  if (refLine[b1] + 3 < columns) {
-	    a0New = codingLine[++a0] = refLine[b1] + 3;
-	    ++b1;
-	    while (refLine[b1] <= a0New && refLine[b1] < columns) {
-	      b1 += 2;
+	    while (refLine[b1i] <= codingLine[a0i] && refLine[b1i] < columns) {
+	      b1i += 2;
 	    }
-	  } else {
-	    a0New = codingLine[++a0] = columns;
 	  }
 	  break;
-	case twoDimVertL3:
-	  if (refLine[b1] - 3 > a0New || (a0 == 0 && refLine[b1] == 3)) {
-	    a0New = codingLine[++a0] = refLine[b1] - 3;
-	    --b1;
-	    while (refLine[b1] <= a0New && refLine[b1] < columns) {
-	      b1 += 2;
+	case twoDimVertL1:
+	  addPixelsNeg(refLine[b1i] - 1, blackPixels);
+	  blackPixels ^= 1;
+	  if (codingLine[a0i] < columns) {
+	    if (b1i > 0) {
+	      --b1i;
+	    } else {
+	      ++b1i;
 	    }
+	    while (refLine[b1i] <= codingLine[a0i] && refLine[b1i] < columns) {
+	      b1i += 2;
+	    }
 	  }
 	  break;
 	case EOF:
+	  addPixels(columns, 0);
 	  eof = gTrue;
-	  codingLine[a0 = 0] = columns;
-	  return EOF;
+	  break;
 	default:
 	  error(getPos(), "Bad 2D code %04x in CCITTFax stream", code1);
+	  addPixels(columns, 0);
 	  err = gTrue;
 	  break;
 	}
-      } while (codingLine[a0] < columns);
+      }
 
     // 1-D encoding
     } else {
-      codingLine[a0 = 0] = 0;
-      while (1) {
+      codingLine[0] = 0;
+      a0i = 0;
+      blackPixels = 0;
+      while (codingLine[a0i] < columns) {
 	code1 = 0;
-	do {
-	  code1 += code3 = getWhiteCode();
-	} while (code3 >= 64);
-	codingLine[a0+1] = codingLine[a0] + code1;
-	++a0;
-	if (codingLine[a0] >= columns) {
-	  break;
+	if (blackPixels) {
+	  do {
+	    code1 += code3 = getBlackCode();
+	  } while (code3 >= 64);
+	} else {
+	  do {
+	    code1 += code3 = getWhiteCode();
+	  } while (code3 >= 64);
 	}
-	code2 = 0;
-	do {
-	  code2 += code3 = getBlackCode();
-	} while (code3 >= 64);
-	codingLine[a0+1] = codingLine[a0] + code2;
-	++a0;
-	if (codingLine[a0] >= columns) {
-	  break;
-	}
+	addPixels(codingLine[a0i] + code1, blackPixels);
+	blackPixels ^= 1;
       }
     }
 
-    if (codingLine[a0] != columns) {
-      error(getPos(), "CCITTFax row is wrong length (%d)", codingLine[a0]);
-      // force the row to be the correct length
-      while (codingLine[a0] > columns) {
-	--a0;
-      }
-      codingLine[++a0] = columns;
-      err = gTrue;
-    }
-
     // byte-align the row
     if (byteAlign) {
       inputBits &= ~7;
@@ -1562,14 +1593,17 @@
     // this if we know the stream contains end-of-line markers because
     // the "just plow on" technique tends to work better otherwise
     } else if (err && endOfLine) {
-      do {
+      while (1) {
+	code1 = lookBits(13);
 	if (code1 == EOF) {
 	  eof = gTrue;
 	  return EOF;
 	}
+	if ((code1 >> 1) == 0x001) {
+	  break;
+	}
 	eatBits(1);
-	code1 = lookBits(13);
-      } while ((code1 >> 1) != 0x001);
+      }
       eatBits(12); 
       if (encoding > 0) {
 	eatBits(1);
@@ -1577,11 +1611,11 @@
       }
     }
 
-    a0 = 0;
-    outputBits = codingLine[1] - codingLine[0];
-    if (outputBits == 0) {
-      a0 = 1;
-      outputBits = codingLine[2] - codingLine[1];
+    // set up for output
+    if (codingLine[0] > 0) {
+      outputBits = codingLine[a0i = 0];
+    } else {
+      outputBits = codingLine[a0i = 1];
     }
 
     ++row;
@@ -1589,39 +1623,43 @@
 
   // get a byte
   if (outputBits >= 8) {
-    ret = ((a0 & 1) == 0) ? 0xff : 0x00;
-    if ((outputBits -= 8) == 0) {
-      ++a0;
-      if (codingLine[a0] < columns) {
-	outputBits = codingLine[a0 + 1] - codingLine[a0];
-      }
+    buf = (a0i & 1) ? 0x00 : 0xff;
+    outputBits -= 8;
+    if (outputBits == 0 && codingLine[a0i] < columns) {
+      ++a0i;
+      outputBits = codingLine[a0i] - codingLine[a0i - 1];
     }
   } else {
     bits = 8;
-    ret = 0;
+    buf = 0;
     do {
       if (outputBits > bits) {
-	i = bits;
+	buf <<= bits;
+	if (!(a0i & 1)) {
+	  buf |= 0xff >> (8 - bits);
+	}
+	outputBits -= bits;
 	bits = 0;
-	if ((a0 & 1) == 0) {
-	  ret |= 0xff >> (8 - i);
+      } else {
+	buf <<= outputBits;
+	if (!(a0i & 1)) {
+	  buf |= 0xff >> (8 - outputBits);
 	}
-	outputBits -= i;
-      } else {
-	i = outputBits;
 	bits -= outputBits;
-	if ((a0 & 1) == 0) {
-	  ret |= (0xff >> (8 - i)) << bits;
-	}
 	outputBits = 0;
-	++a0;
-	if (codingLine[a0] < columns) {
-	  outputBits = codingLine[a0 + 1] - codingLine[a0];
+	if (codingLine[a0i] < columns) {
+	  ++a0i;
+	  outputBits = codingLine[a0i] - codingLine[a0i - 1];
+	} else if (bits > 0) {
+	  buf <<= bits;
+	  bits = 0;
 	}
       }
-    } while (bits > 0 && codingLine[a0] < columns);
+    } while (bits);
   }
-  buf = black ? (ret ^ 0xff) : ret;
+  if (black) {
+    buf ^= 0xff;
+  }
   return buf;
 }
 
@@ -1663,6 +1701,9 @@
   code = 0; // make gcc happy
   if (endOfBlock) {
     code = lookBits(12);
+    if (code == EOF) {
+      return 1;
+    }
     if ((code >> 5) == 0) {
       p = &whiteTab1[code];
     } else {
@@ -1675,6 +1716,9 @@
   } else {
     for (n = 1; n <= 9; ++n) {
       code = lookBits(n);
+      if (code == EOF) {
+	return 1;
+      }
       if (n < 9) {
 	code <<= 9 - n;
       }
@@ -1686,6 +1730,9 @@
     }
     for (n = 11; n <= 12; ++n) {
       code = lookBits(n);
+      if (code == EOF) {
+	return 1;
+      }
       if (n < 12) {
 	code <<= 12 - n;
       }
@@ -1711,9 +1758,12 @@
   code = 0; // make gcc happy
   if (endOfBlock) {
     code = lookBits(13);
+    if (code == EOF) {
+      return 1;
+    }
     if ((code >> 7) == 0) {
       p = &blackTab1[code];
-    } else if ((code >> 9) == 0) {
+    } else if ((code >> 9) == 0 && (code >> 7) != 0) {
       p = &blackTab2[(code >> 1) - 64];
     } else {
       p = &blackTab3[code >> 7];
@@ -1725,6 +1775,9 @@
   } else {
     for (n = 2; n <= 6; ++n) {
       code = lookBits(n);
+      if (code == EOF) {
+	return 1;
+      }
       if (n < 6) {
 	code <<= 6 - n;
       }
@@ -1736,6 +1789,9 @@
     }
     for (n = 7; n <= 12; ++n) {
       code = lookBits(n);
+      if (code == EOF) {
+	return 1;
+      }
       if (n < 12) {
 	code <<= 12 - n;
       }
@@ -1749,6 +1805,9 @@
     }
     for (n = 10; n <= 13; ++n) {
       code = lookBits(n);
+      if (code == EOF) {
+	return 1;
+      }
       if (n < 13) {
 	code <<= 13 - n;
       }
@@ -1963,6 +2022,12 @@
     // allocate a buffer for the whole image
     bufWidth = ((width + mcuWidth - 1) / mcuWidth) * mcuWidth;
     bufHeight = ((height + mcuHeight - 1) / mcuHeight) * mcuHeight;
+    if (bufWidth <= 0 || bufHeight <= 0 ||
+	bufWidth > INT_MAX / bufWidth / (int)sizeof(int)) {
+      error(getPos(), "Invalid image size in DCT stream");
+      y = height;
+      return;
+    }
     for (i = 0; i < numComps; ++i) {
       frameBuf[i] = (int *)gmallocn(bufWidth * bufHeight, sizeof(int));
       memset(frameBuf[i], 0, bufWidth * bufHeight * sizeof(int));
@@ -3038,6 +3103,11 @@
   }
   scanInfo.firstCoeff = str->getChar();
   scanInfo.lastCoeff = str->getChar();
+  if (scanInfo.firstCoeff < 0 || scanInfo.lastCoeff > 63 ||
+      scanInfo.firstCoeff > scanInfo.lastCoeff) {
+    error(getPos(), "Bad DCT coefficient numbers in scan info block");
+    return gFalse;
+  }
   c = str->getChar();
   scanInfo.ah = (c >> 4) & 0x0f;
   scanInfo.al = c & 0x0f;
Index: kpdf/xpdf/xpdf/Stream.h
===================================================================
--- kpdf/xpdf/xpdf/Stream.h	(.../tags/KDE/3.5.8/kdegraphics)	(wersja 734657)
+++ kpdf/xpdf/xpdf/Stream.h	(.../branches/KDE/3.5/kdegraphics)	(wersja 734657)
@@ -528,13 +528,15 @@
   int row;			// current row
   int inputBuf;			// input buffer
   int inputBits;		// number of bits in input buffer
-  short *refLine;		// reference line changing elements
-  int b1;			// index into refLine
-  short *codingLine;		// coding line changing elements
-  int a0;			// index into codingLine
+  int *codingLine;		// coding line changing elements
+  int *refLine;			// reference line changing elements
+  int a0i;			// index into codingLine
+  GBool err;			// error on current line
   int outputBits;		// remaining ouput bits
   int buf;			// character buffer
 
+  void addPixels(int a1, int black);
+  void addPixelsNeg(int a1, int black);
   short getTwoDimCode();
   short getWhiteCode();
   short getBlackCode();
Index: kpdf/xpdf/goo/gmem.cc
===================================================================
--- kpdf/xpdf/goo/gmem.cc	(.../tags/KDE/3.5.8/kdegraphics)	(wersja 734657)
+++ kpdf/xpdf/goo/gmem.cc	(.../branches/KDE/3.5/kdegraphics)	(wersja 734657)
@@ -172,6 +172,25 @@
   return gmalloc(n);
 }
 
+void *gmallocn_checkoverflow(int nObjs, int objSize) GMEM_EXCEP {
+  int n;
+
+  if (nObjs == 0) {
+    return NULL;
+  }
+  n = nObjs * objSize;
+  if (objSize <= 0 || nObjs < 0 || nObjs >= INT_MAX / objSize) {
+#if USE_EXCEPTIONS
+    throw GMemException();
+#else
+    fprintf(stderr, "Bogus memory allocation size\n");
+    return NULL;
+#endif
+  }
+  return gmalloc(n);
+}
+
+
 void *greallocn(void *p, int nObjs, int objSize) GMEM_EXCEP {
   int n;
 
Index: kpdf/xpdf/goo/gmem.h
===================================================================
--- kpdf/xpdf/goo/gmem.h	(.../tags/KDE/3.5.8/kdegraphics)	(wersja 734657)
+++ kpdf/xpdf/goo/gmem.h	(.../branches/KDE/3.5/kdegraphics)	(wersja 734657)
@@ -52,6 +52,7 @@
  */
 extern void *gmallocn(int nObjs, int objSize) GMEM_EXCEP;
 extern void *greallocn(void *p, int nObjs, int objSize) GMEM_EXCEP;
+extern void *gmallocn_checkoverflow(int nObjs, int objSize) GMEM_EXCEP;
 
 /*
  * Same as free, but checks for and ignores NULL pointers.
Index: kpdf/xpdf/splash/Splash.h
===================================================================
--- kpdf/xpdf/splash/Splash.h	(.../tags/KDE/3.5.8/kdegraphics)	(wersja 734657)
+++ kpdf/xpdf/splash/Splash.h	(.../branches/KDE/3.5/kdegraphics)	(wersja 734657)
@@ -151,7 +151,7 @@
 
   // Draw a glyph, using the current fill pattern.  This function does
   // not free any data, i.e., it ignores glyph->freeData.
-  SplashError fillGlyph(SplashCoord x, SplashCoord y,
+  void fillGlyph(SplashCoord x, SplashCoord y,
 			SplashGlyphBitmap *glyph);
 
   // Draws an image mask using the fill color.  This will read <h>
@@ -267,7 +267,7 @@
   SplashPath *makeDashedPath(SplashPath *xPath);
   SplashError fillWithPattern(SplashPath *path, GBool eo,
 			      SplashPattern *pattern, SplashCoord alpha);
-  SplashError fillGlyph2(int x0, int y0, SplashGlyphBitmap *glyph);
+  void fillGlyph2(int x0, int y0, SplashGlyphBitmap *glyph, GBool noclip);
   void dumpPath(SplashPath *path);
   void dumpXPath(SplashXPath *path);
 
Index: kpdf/xpdf/splash/SplashFont.cc
===================================================================
--- kpdf/xpdf/splash/SplashFont.cc	(.../tags/KDE/3.5.8/kdegraphics)	(wersja 734657)
+++ kpdf/xpdf/splash/SplashFont.cc	(.../branches/KDE/3.5/kdegraphics)	(wersja 734657)
@@ -74,11 +74,15 @@
   } else {
     cacheSets = 1;
   }
-  cache = (Guchar *)gmallocn(cacheSets * cacheAssoc, glyphSize);
-  cacheTags = (SplashFontCacheTag *)gmallocn(cacheSets * cacheAssoc,
+  cache = (Guchar *)gmallocn_checkoverflow(cacheSets * cacheAssoc, glyphSize);
+  if (cache != NULL) {
+    cacheTags = (SplashFontCacheTag *)gmallocn(cacheSets * cacheAssoc,
 					     sizeof(SplashFontCacheTag));
-  for (i = 0; i < cacheSets * cacheAssoc; ++i) {
-    cacheTags[i].mru = i & (cacheAssoc - 1);
+    for (i = 0; i < cacheSets * cacheAssoc; ++i) {
+      cacheTags[i].mru = i & (cacheAssoc - 1);
+    }
+  } else {
+    cacheAssoc = 0;
   }
 }
 
@@ -93,7 +97,7 @@
 }
 
 GBool SplashFont::getGlyph(int c, int xFrac, int yFrac,
-			   SplashGlyphBitmap *bitmap) {
+			   SplashGlyphBitmap *bitmap, int x0, int y0, SplashClip *clip, SplashClipResult *clipRes) {
   SplashGlyphBitmap bitmap2;
   int size;
   Guchar *p;
@@ -127,15 +131,28 @@
       bitmap->aa = aa;
       bitmap->data = cache + (i+j) * glyphSize;
       bitmap->freeData = gFalse;
+
+      *clipRes = clip->testRect(x0 - bitmap->x,
+                                y0 - bitmap->y,
+                                x0 - bitmap->x + bitmap->w - 1,
+                                y0 - bitmap->y + bitmap->h - 1);
+
       return gTrue;
     }
   }
 
   // generate the glyph bitmap
-  if (!makeGlyph(c, xFrac, yFrac, &bitmap2)) {
+  if (!makeGlyph(c, xFrac, yFrac, &bitmap2, x0, y0, clip, clipRes)) {
     return gFalse;
   }
 
+  if (*clipRes == splashClipAllOutside)
+  {
+    bitmap->freeData = gFalse;
+    if (bitmap2.freeData) gfree(bitmap2.data);
+    return gTrue;
+  }
+
   // if the glyph doesn't fit in the bounding box, return a temporary
   // uncached bitmap
   if (bitmap2.w > glyphW || bitmap2.h > glyphH) {
Index: kpdf/xpdf/splash/SplashFont.h
===================================================================
--- kpdf/xpdf/splash/SplashFont.h	(.../tags/KDE/3.5.8/kdegraphics)	(wersja 734657)
+++ kpdf/xpdf/splash/SplashFont.h	(.../branches/KDE/3.5/kdegraphics)	(wersja 734657)
@@ -15,6 +15,7 @@
 
 #include "gtypes.h"
 #include "SplashTypes.h"
+#include "SplashClip.h"
 
 struct SplashGlyphBitmap;
 struct SplashFontCacheTag;
@@ -66,12 +67,12 @@
   // should override this to zero out xFrac and/or yFrac if they don't
   // support fractional coordinates.
   virtual GBool getGlyph(int c, int xFrac, int yFrac,
-			 SplashGlyphBitmap *bitmap);
+			 SplashGlyphBitmap *bitmap, int x0, int y0, SplashClip *clip, SplashClipResult *clipRes);
 
   // Rasterize a glyph.  The <xFrac> and <yFrac> values are the same
   // as described for getGlyph.
   virtual GBool makeGlyph(int c, int xFrac, int yFrac,
-			  SplashGlyphBitmap *bitmap) = 0;
+			  SplashGlyphBitmap *bitmap, int x0, int y0, SplashClip *clip, SplashClipResult *clipRes) = 0;
 
   // Return the path for a glyph.
   virtual SplashPath *getGlyphPath(int c) = 0;
Index: kpdf/xpdf/splash/SplashT1Font.h
===================================================================
--- kpdf/xpdf/splash/SplashT1Font.h	(.../tags/KDE/3.5.8/kdegraphics)	(wersja 734657)
+++ kpdf/xpdf/splash/SplashT1Font.h	(.../branches/KDE/3.5/kdegraphics)	(wersja 734657)
@@ -33,12 +33,12 @@
 
   // Munge xFrac and yFrac before calling SplashFont::getGlyph.
   virtual GBool getGlyph(int c, int xFrac, int yFrac,
-			 SplashGlyphBitmap *bitmap);
+			 SplashGlyphBitmap *bitmap, int x0, int y0, SplashClip *clip, SplashClipResult *clipRes);
 
   // Rasterize a glyph.  The <xFrac> and <yFrac> values are the same
   // as described for getGlyph.
   virtual GBool makeGlyph(int c, int xFrac, int yFrac,
-			  SplashGlyphBitmap *bitmap);
+			  SplashGlyphBitmap *bitmap, int x0, int y0, SplashClip *clip, SplashClipResult *clipRes);
 
   // Return the path for a glyph.
   virtual SplashPath *getGlyphPath(int c);
Index: kpdf/xpdf/splash/Splash.cc
===================================================================
--- kpdf/xpdf/splash/Splash.cc	(.../tags/KDE/3.5.8/kdegraphics)	(wersja 734657)
+++ kpdf/xpdf/splash/Splash.cc	(.../branches/KDE/3.5/kdegraphics)	(wersja 734657)
@@ -1626,7 +1626,7 @@
   SplashGlyphBitmap glyph;
   SplashCoord xt, yt;
   int x0, y0, xFrac, yFrac;
-  SplashError err;
+  SplashClipResult clipRes;
 
   if (debugMode) {
     printf("fillChar: x=%.2f y=%.2f c=%3d=0x%02x='%c'\n",
@@ -1637,17 +1637,20 @@
   xFrac = splashFloor((xt - x0) * splashFontFraction);
   y0 = splashFloor(yt);
   yFrac = splashFloor((yt - y0) * splashFontFraction);
-  if (!font->getGlyph(c, xFrac, yFrac, &glyph)) {
+  if (!font->getGlyph(c, xFrac, yFrac, &glyph, x0, y0, state->clip, &clipRes)) {
     return splashErrNoGlyph;
   }
-  err = fillGlyph2(x0, y0, &glyph);
+  if (clipRes != splashClipAllOutside) {
+    fillGlyph2(x0, y0, &glyph, clipRes == splashClipAllInside);
+  }
+  opClipRes = clipRes;
   if (glyph.freeData) {
     gfree(glyph.data);
   }
-  return err;
+  return splashOk;
 }
 
-SplashError Splash::fillGlyph(SplashCoord x, SplashCoord y,
+void Splash::fillGlyph(SplashCoord x, SplashCoord y,
 			      SplashGlyphBitmap *glyph) {
   SplashCoord xt, yt;
   int x0, y0;
@@ -1655,24 +1658,22 @@
   transform(state->matrix, x, y, &xt, &yt);
   x0 = splashFloor(xt);
   y0 = splashFloor(yt);
-  return fillGlyph2(x0, y0, glyph);
+  SplashClipResult clipRes = state->clip->testRect(x0 - glyph->x,
+                             y0 - glyph->y,
+                             x0 - glyph->x + glyph->w - 1,
+                             y0 - glyph->y + glyph->h - 1);
+  if (clipRes != splashClipAllOutside) {
+    fillGlyph2(x0, y0, glyph, clipRes == splashClipAllInside);
+  }
+  opClipRes = clipRes;
 }
 
-SplashError Splash::fillGlyph2(int x0, int y0, SplashGlyphBitmap *glyph) {
+void Splash::fillGlyph2(int x0, int y0, SplashGlyphBitmap *glyph, GBool noClip) {
   SplashPipe pipe;
-  SplashClipResult clipRes;
-  GBool noClip;
   int alpha0, alpha;
   Guchar *p;
   int x1, y1, xx, xx1, yy;
 
-  if ((clipRes = state->clip->testRect(x0 - glyph->x,
-				       y0 - glyph->y,
-				       x0 - glyph->x + glyph->w - 1,
-				       y0 - glyph->y + glyph->h - 1))
-      != splashClipAllOutside) {
-    noClip = clipRes == splashClipAllInside;
-
     if (noClip) {
       if (glyph->aa) {
 	pipeInit(&pipe, x0 - glyph->x, y0 - glyph->y,
@@ -1763,10 +1764,6 @@
 	}
       }
     }
-  }
-  opClipRes = clipRes;
-
-  return splashOk;
 }
 
 SplashError Splash::fillImageMask(SplashImageMaskSource src, void *srcData,
Index: kpdf/xpdf/splash/SplashFTFont.cc
===================================================================
--- kpdf/xpdf/splash/SplashFTFont.cc	(.../tags/KDE/3.5.8/kdegraphics)	(wersja 734657)
+++ kpdf/xpdf/splash/SplashFTFont.cc	(.../branches/KDE/3.5/kdegraphics)	(wersja 734657)
@@ -147,12 +147,12 @@
 }
 
 GBool SplashFTFont::getGlyph(int c, int xFrac, int /*yFrac*/,
-			     SplashGlyphBitmap *bitmap) {
-  return SplashFont::getGlyph(c, xFrac, 0, bitmap);
+			     SplashGlyphBitmap *bitmap, int x0, int y0, SplashClip *clip, SplashClipResult *clipRes) {
+  return SplashFont::getGlyph(c, xFrac, 0, bitmap, x0, y0, clip, clipRes);
 }
 
 GBool SplashFTFont::makeGlyph(int c, int xFrac, int /*yFrac*/,
-			      SplashGlyphBitmap *bitmap) {
+			      SplashGlyphBitmap *bitmap, int x0, int y0, SplashClip *clip, SplashClipResult *clipRes) {
   SplashFTFontFile *ff;
   FT_Vector offset;
   FT_GlyphSlot slot;
@@ -196,6 +196,24 @@
     return gFalse;
   }
 #endif
+
+  FT_Glyph_Metrics *glyphMetrics = &(ff->face->glyph->metrics);
+  // prelimirary values from FT_Glyph_Metrics
+  bitmap->x = splashRound(-glyphMetrics->horiBearingX / 64.0);
+  bitmap->y = splashRound(glyphMetrics->horiBearingY / 64.0);
+  bitmap->w = splashRound(glyphMetrics->width / 64.0);
+  bitmap->h = splashRound(glyphMetrics->height / 64.0);
+
+  *clipRes = clip->testRect(x0 - bitmap->x,
+                            y0 - bitmap->y,
+                            x0 - bitmap->x + bitmap->w - 1,
+                            y0 - bitmap->y + bitmap->h - 1);
+  if (*clipRes == splashClipAllOutside)
+  {
+    bitmap->freeData = gFalse;
+    return gTrue;
+  }
+
   if (FT_Render_Glyph(slot, aa ? ft_render_mode_normal
 		               : ft_render_mode_mono)) {
     return gFalse;
Index: kpdf/xpdf/splash/SplashFTFont.h
===================================================================
--- kpdf/xpdf/splash/SplashFTFont.h	(.../tags/KDE/3.5.8/kdegraphics)	(wersja 734657)
+++ kpdf/xpdf/splash/SplashFTFont.h	(.../branches/KDE/3.5/kdegraphics)	(wersja 734657)
@@ -35,12 +35,12 @@
 
   // Munge xFrac and yFrac before calling SplashFont::getGlyph.
   virtual GBool getGlyph(int c, int xFrac, int yFrac,
-			 SplashGlyphBitmap *bitmap);
+			 SplashGlyphBitmap *bitmap, int x0, int y0, SplashClip *clip, SplashClipResult *clipRes);
 
   // Rasterize a glyph.  The <xFrac> and <yFrac> values are the same
   // as described for getGlyph.
   virtual GBool makeGlyph(int c, int xFrac, int yFrac,
-			  SplashGlyphBitmap *bitmap);
+			  SplashGlyphBitmap *bitmap, int x0, int y0, SplashClip *clip, SplashClipResult *clipRes);
 
   // Return the path for a glyph.
   virtual SplashPath *getGlyphPath(int c);
Index: kpdf/xpdf/splash/SplashT1Font.cc
===================================================================
--- kpdf/xpdf/splash/SplashT1Font.cc	(.../tags/KDE/3.5.8/kdegraphics)	(wersja 734657)
+++ kpdf/xpdf/splash/SplashT1Font.cc	(.../branches/KDE/3.5/kdegraphics)	(wersja 734657)
@@ -176,12 +176,12 @@
 }
 
 GBool SplashT1Font::getGlyph(int c, int xFrac, int yFrac,
-			     SplashGlyphBitmap *bitmap) {
-  return SplashFont::getGlyph(c, 0, 0, bitmap);
+			     SplashGlyphBitmap *bitmap, int x0, int y0, SplashClip *clip, SplashClipResult *clipRes) {
+  return SplashFont::getGlyph(c, 0, 0, bitmap, x0, y0, clip, clipRes);
 }
 
 GBool SplashT1Font::makeGlyph(int c, int xFrac, int yFrac,
-			      SplashGlyphBitmap *bitmap) {
+			      SplashGlyphBitmap *bitmap, int x0, int y0, SplashClip *clip, SplashClipResult *clipRes) {
   GLYPH *glyph;
   int n, i;
 
@@ -211,6 +211,11 @@
     bitmap->freeData = gTrue;
   }
 
+  *clipRes = clip->testRect(x0 - bitmap->x,
+                            y0 - bitmap->y,
+                            x0 - bitmap->x + bitmap->w - 1,
+                            y0 - bitmap->y + bitmap->h - 1);
+
   return gTrue;
 }
 
Index: kfaxview/kfaxmultipage_tiff.desktop
===================================================================
--- kfaxview/kfaxmultipage_tiff.desktop	(.../tags/KDE/3.5.8/kdegraphics)	(wersja 734657)
+++ kfaxview/kfaxmultipage_tiff.desktop	(.../branches/KDE/3.5/kdegraphics)	(wersja 734657)
@@ -16,6 +16,7 @@
 Comment[da]=Kviewshell-plugin for telefaxfiler
 Comment[de]=Ein Modul für KViewShell zum Betrachten von Faxdateien
 Comment[el]=Πρόσθετο του KViewShell για αρχεία φαξ
+Comment[eo]=KViewShell-kromaĵo for faksdosieroj
 Comment[es]=Extensión KViewShell para archivos de fax
 Comment[et]=KView faksifailide plugin
 Comment[eu]=Fax fitxategientzatko KViewShell-en plugina
Index: kfaxview/kfaxmultipage.desktop
===================================================================
--- kfaxview/kfaxmultipage.desktop	(.../tags/KDE/3.5.8/kdegraphics)	(wersja 734657)
+++ kfaxview/kfaxmultipage.desktop	(.../branches/KDE/3.5/kdegraphics)	(wersja 734657)
@@ -19,6 +19,7 @@
 Comment[da]=Kviewshell-plugin for telefaxfiler
 Comment[de]=Ein Modul für KViewShell zum Betrachten von Faxdateien
 Comment[el]=Πρόσθετο του KViewShell για αρχεία φαξ
+Comment[eo]=KViewShell-kromaĵo for faksdosieroj
 Comment[es]=Extensión KViewShell para archivos de fax
 Comment[et]=KView faksifailide plugin
 Comment[eu]=Fax fitxategientzatko KViewShell-en plugina
Index: kview/kviewcanvas/config/kviewcanvasconfig.desktop
===================================================================
--- kview/kviewcanvas/config/kviewcanvasconfig.desktop	(.../tags/KDE/3.5.8/kdegraphics)	(wersja 734657)
+++ kview/kviewcanvas/config/kviewcanvasconfig.desktop	(.../branches/KDE/3.5/kdegraphics)	(wersja 734657)
@@ -23,6 +23,7 @@
 Name[da]=Fremviser
 Name[de]=Betrachter
 Name[el]=Προβολέας
+Name[eo]=Rigardilo
 Name[es]=Visor
 Name[et]=Näitaja
 Name[eu]=Ikustailua
@@ -75,6 +76,7 @@
 Comment[da]=Generel indstilling af KViewCanvas
 Comment[de]=Allgemeine Einstellungen für KViewCanvas
 Comment[el]=Γενική ρύθμιση του KViewCanvas
+Comment[eo]=Ĝenerala Agordo de KViewCanvas
 Comment[es]=Configuración general de KViewCanvas
 Comment[et]=KView lõuendite üldine seadistus
 Comment[eu]=KViewCanvas konfigurazio orokorra
Index: kview/config/kviewgeneralconfig.desktop
===================================================================
--- kview/config/kviewgeneralconfig.desktop	(.../tags/KDE/3.5.8/kdegraphics)	(wersja 734657)
+++ kview/config/kviewgeneralconfig.desktop	(.../branches/KDE/3.5/kdegraphics)	(wersja 734657)
@@ -88,6 +88,7 @@
 Comment[da]=Indstilling af den alenestående udgave af KView
 Comment[de]=Einstellungen für die Anwendung KView
 Comment[el]=Ρύθμιση της standalone έκδοσης του KView
+Comment[eo]=Agordo por la aŭtonoma versio de KView
 Comment[es]=Configuración para la versión independiente de KView
 Comment[et]=KView iseseisva versiooni seadistus
 Comment[eu]=KView programaren konfigurazioa
Index: kview/config/plugins/kviewpluginsconfig.desktop
===================================================================
--- kview/config/plugins/kviewpluginsconfig.desktop	(.../tags/KDE/3.5.8/kdegraphics)	(wersja 734657)
+++ kview/config/plugins/kviewpluginsconfig.desktop	(.../branches/KDE/3.5/kdegraphics)	(wersja 734657)
@@ -23,6 +23,7 @@
 Name[da]=Plugin
 Name[de]=Module
 Name[el]=Πρόσθετα
+Name[eo]=Kromaĵoj
 Name[es]=Extensiones
 Name[et]=Pluginad
 Name[eu]=Pluginak
@@ -75,6 +76,7 @@
 Comment[da]=Vælg og indstil dine plugin
 Comment[de]=Auswahl und Einrichtung der Module
 Comment[el]=Επιλέξτε και ρυθμίστε τα πρόσθετα σας
+Comment[eo]=Elektu kaj agordu viajn kromprogramojn
 Comment[es]=Seleccione y configure sus extensiones
 Comment[et]=Pluginate valimine ja seadistamine
 Comment[eu]=Aukeratu eta konfigurau zure pluginak
Index: kview/config/kview.setdlg
===================================================================
--- kview/config/kview.setdlg	(.../tags/KDE/3.5.8/kdegraphics)	(wersja 734657)
+++ kview/config/kview.setdlg	(.../branches/KDE/3.5/kdegraphics)	(wersja 734657)
@@ -10,6 +10,7 @@
 Name[da]=Fremviser
 Name[de]=Betrachter
 Name[el]=Προβολέας
+Name[eo]=Rigardilo
 Name[es]=Visor
 Name[et]=Näitaja
 Name[eu]=Ikustailua
Index: kview/kviewviewer/kviewviewer.desktop
===================================================================
--- kview/kviewviewer/kviewviewer.desktop	(.../tags/KDE/3.5.8/kdegraphics)	(wersja 734657)
+++ kview/kviewviewer/kviewviewer.desktop	(.../branches/KDE/3.5/kdegraphics)	(wersja 734657)
@@ -70,6 +70,7 @@
 Name[da]=KView-billedfremviser
 Name[de]=Bildbetrachter KView
 Name[el]=Προβολέας εικόνων KView
+Name[eo]=KView-Bildrigardilo
 Name[es]=Visor de imágenes de KView
 Name[et]=KView pildifailide näitaja
 Name[eu]=KView irudi ikustailea
Index: kview/kviewviewer/config/kviewviewerpluginsconfig.desktop
===================================================================
--- kview/kviewviewer/config/kviewviewerpluginsconfig.desktop	(.../tags/KDE/3.5.8/kdegraphics)	(wersja 734657)
+++ kview/kviewviewer/config/kviewviewerpluginsconfig.desktop	(.../branches/KDE/3.5/kdegraphics)	(wersja 734657)
@@ -23,6 +23,7 @@
 Name[da]=Plugin
 Name[de]=Module
 Name[el]=Πρόσθετα
+Name[eo]=Kromaĵoj
 Name[es]=Extensiones
 Name[et]=Pluginad
 Name[eu]=Pluginak
@@ -75,6 +76,7 @@
 Comment[da]=Vælg og indstil dine plugin
 Comment[de]=Auswahl und Einrichtung der Module
 Comment[el]=Επιλέξτε και ρυθμίστε τα πρόσθετα σας
+Comment[eo]=Elektu kaj agordu viajn kromprogramojn
 Comment[es]=Seleccione y configure sus extensiones
 Comment[et]=Pluginate valimine ja seadistamine
 Comment[eu]=Aukeratu eta konfigurau zure pluginak
Index: kview/modules/effects/kvieweffects.desktop
===================================================================
--- kview/modules/effects/kvieweffects.desktop	(.../tags/KDE/3.5.8/kdegraphics)	(wersja 734657)
+++ kview/modules/effects/kvieweffects.desktop	(.../branches/KDE/3.5/kdegraphics)	(wersja 734657)
@@ -21,6 +21,7 @@
 Name[da]=Effekter
 Name[de]=Effekte
 Name[el]=Εφέ
+Name[eo]=Efektoj
 Name[es]=Efectos
 Name[et]=Efektid
 Name[eu]=Efectuak
@@ -74,6 +75,7 @@
 Comment[da]=Sørger for nogle billedeffekter
 Comment[de]=Stellt einige Bildverarbeitungseffekte zur Verfügung
 Comment[el]=Παρέχει μερικά εφέ εικόνας
+Comment[eo]=Provizas kelkajn bildefektojn
 Comment[es]=Proporciona alguno efectos para imágenes
 Comment[et]=Mõned pildiefektid
 Comment[eu]=Irudi efektu batzuk eskuratzen ditu
Index: kview/modules/browser/kviewbrowser.desktop
===================================================================
--- kview/modules/browser/kviewbrowser.desktop	(.../tags/KDE/3.5.8/kdegraphics)	(wersja 734657)
+++ kview/modules/browser/kviewbrowser.desktop	(.../branches/KDE/3.5/kdegraphics)	(wersja 734657)
@@ -82,6 +82,7 @@
 Comment[da]=Lader dig gennemse alle billederne i denne mappe.
 Comment[de]=Ermöglicht das Durchsehen der Bilder im aktuellen Ordner.
 Comment[el]=Σας επιτρέπει να περιηγηθείτε σε όλες τις εικόνες στον τρέχον κατάλογο.
+Comment[eo]=Permesas al vi povas trarigardi ĉiujn bildojn en la nuna dosierujo.
 Comment[es]=Le permite navegar por todas las imágenes del directorio actual.
 Comment[et]=Võimaldab sirvida aktiivse kataloogi kõiki pilte.
 Comment[eu]=Uneko direktorioko irudien artean nabigatzen uzten dizu.
Index: kview/modules/presenter/config/kviewpresenterconfig.desktop
===================================================================
--- kview/modules/presenter/config/kviewpresenterconfig.desktop	(.../tags/KDE/3.5.8/kdegraphics)	(wersja 734657)
+++ kview/modules/presenter/config/kviewpresenterconfig.desktop	(.../branches/KDE/3.5/kdegraphics)	(wersja 734657)
@@ -18,6 +18,7 @@
 Name[cy]=Enw
 Name[da]=Navn
 Name[el]=Όνομα
+Name[eo]=Nomo
 Name[es]=Nombre
 Name[et]=Nimi
 Name[eu]=Izena
@@ -71,6 +72,7 @@
 Comment[da]=Kommentar
 Comment[de]=Kommentar
 Comment[el]=Σχόλιο
+Comment[eo]=Komento
 Comment[es]=Comentario
 Comment[et]=Kommentaar
 Comment[eu]=Iruzkina
Index: kview/modules/presenter/imagelistdialog.ui
===================================================================
--- kview/modules/presenter/imagelistdialog.ui	(.../tags/KDE/3.5.8/kdegraphics)	(wersja 734657)
+++ kview/modules/presenter/imagelistdialog.ui	(.../branches/KDE/3.5/kdegraphics)	(wersja 734657)
@@ -253,6 +253,7 @@
     </connection>
 </connections>
 <includes>
+    <include location="global" impldecl="in declaration">kdialog.h</include>
     <include location="global" impldecl="in implementation">kdebug.h</include>
     <include location="global" impldecl="in implementation">kimageviewer/viewer.h</include>
     <include location="global" impldecl="in implementation">kio/netaccess.h</include>
Index: kview/modules/template/kviewtemplate.desktop
===================================================================
--- kview/modules/template/kviewtemplate.desktop	(.../tags/KDE/3.5.8/kdegraphics)	(wersja 734657)
+++ kview/modules/template/kviewtemplate.desktop	(.../branches/KDE/3.5/kdegraphics)	(wersja 734657)
@@ -80,6 +80,7 @@
 Comment[da]=En længere beskrivelse af hvad dette plugin gør
 Comment[de]=Hier sollte eine längere Beschreibung des Moduls stehen
 Comment[el]=Μια μεγαλύτερη περιγραφή για το τι κάνει το πρόσθετο
+Comment[eo]=Pli longa priskribo pri la kromaĵo
 Comment[es]=Una descripción más completa de la función del plugin
 Comment[et]=Pluginate tegevuse pikemad kirjeldused
 Comment[eu]=Pluginak egiten duenaren azalpen luzeagoa
Index: libkscan/kscandevice.cpp
===================================================================
--- libkscan/kscandevice.cpp	(.../tags/KDE/3.5.8/kdegraphics)	(wersja 734657)
+++ libkscan/kscandevice.cpp	(.../branches/KDE/3.5/kdegraphics)	(wersja 734657)
@@ -228,6 +228,7 @@
   if( storeOptions )  delete (storeOptions );
   kdDebug(29000) << "Calling sane_exit to finish sane!" << endl;
   sane_exit();
+  delete d;
 }
 
 
Index: kpovmodeler/kpovmodeler.desktop
===================================================================
--- kpovmodeler/kpovmodeler.desktop	(.../tags/KDE/3.5.8/kdegraphics)	(wersja 734657)
+++ kpovmodeler/kpovmodeler.desktop	(.../branches/KDE/3.5/kdegraphics)	(wersja 734657)
@@ -4,6 +4,7 @@
 Icon=kpovmodeler
 MimeType=application/x-kpovmodeler;
 Name=KPovModeler
+Name[eo]=KPovModelilo
 Name[es]=Modelador Povray
 Name[he]=מעצב Povray
 Name[nb]=KPov-modellerer
@@ -17,6 +18,7 @@
 GenericName[da]=Povray-modellering
 GenericName[de]=Povray-Modellierer
 GenericName[en_GB]=Povray Modeller
+GenericName[eo]=Povray-modelilo
 GenericName[es]=Modelador Povray
 GenericName[et]=Povray modelleerija
 GenericName[eu]=Povray modelatzailea
Index: kgamma/kcmkgamma/kgamma.desktop
===================================================================
--- kgamma/kcmkgamma/kgamma.desktop	(.../tags/KDE/3.5.8/kdegraphics)	(wersja 734657)
+++ kgamma/kcmkgamma/kgamma.desktop	(.../branches/KDE/3.5/kdegraphics)	(wersja 734657)
@@ -9,6 +9,7 @@
 Comment[da]=Et skærmkalibreringsværktøj
 Comment[de]=Ein Kalibrierungswerkzeug für Monitore
 Comment[el]=Ένα εργαλείο ρύθμισης της οθόνης
+Comment[eo]=Ekrankalibrilo
 Comment[es]=Una herramienta de calibración del monitor
 Comment[et]=Monitori kalibreerija
 Comment[eu]=Monitoreak kalibratzeko tresna
Index: kolourpaint/VERSION
===================================================================
--- kolourpaint/VERSION	(.../tags/KDE/3.5.8/kdegraphics)	(wersja 734657)
+++ kolourpaint/VERSION	(.../branches/KDE/3.5/kdegraphics)	(wersja 734657)
@@ -1 +1 @@
-1.4.8_relight
+1.4.8_relight-post
Index: kolourpaint/kpdocument.cpp
===================================================================
--- kolourpaint/kpdocument.cpp	(.../tags/KDE/3.5.8/kdegraphics)	(wersja 734657)
+++ kolourpaint/kpdocument.cpp	(.../branches/KDE/3.5/kdegraphics)	(wersja 734657)
@@ -619,6 +619,9 @@
                                    bool lossyPrompt,
                                    QWidget *parent)
 {
+    // TODO: Use KIO::NetAccess:mostLocalURL() for accessing home:/ (and other
+    //       such local URLs) for efficiency and because only local writes
+    //       are atomic.
 #if DEBUG_KP_DOCUMENT
     kdDebug () << "kpDocument::savePixmapToFile ("
                << url
Index: kolourpaint/kpmainwindow.h
===================================================================
--- kolourpaint/kpmainwindow.h	(.../tags/KDE/3.5.8/kdegraphics)	(wersja 734657)
+++ kolourpaint/kpmainwindow.h	(.../branches/KDE/3.5/kdegraphics)	(wersja 734657)
@@ -224,6 +224,30 @@
     bool toolIsTextTool () const;
 
     kpSelectionTransparency selectionTransparency () const;
+    // The drawing background color is set to <transparency>.transparentColor()
+    // if the <transparency> is in Transparent mode or if <forceColorChange>
+    // is true (not the default).  [x]
+    //
+    // If <transparency> is in Opaque mode and <forceColorChange> is false,
+    // the background color is not changed because:
+    //
+    //   1. It is ignored by the selection in Opaque mode anyway.
+    //   2. This avoids irritating the user with an unnecessary background
+    //      color change.
+    //
+    // The only case where you should set <forceColorChange> to true is in
+    // kpToolSelectionTransparencyCommand to ensure that the state
+    // is identical to when the command was constructed.
+    // Later: I don't think setting it to true is ever necessary since:
+    //
+    //          1. The background color only counts in Transparent mode.
+    //
+    //          2. Any kpToolSelectionTransparencyCommand that switches to
+    //             Transparent mode will automatically set the background
+    //             color due to the first part of [x] anyway.
+    //
+    // The other fields of <transparency> are copied into the main window
+    // as expected.
     void setSelectionTransparency (const kpSelectionTransparency &transparency,
                                    bool forceColorChange = false);
     int settingSelectionTransparency () const;
Index: kolourpaint/BUGS
===================================================================
--- kolourpaint/BUGS	(.../tags/KDE/3.5.8/kdegraphics)	(wersja 734657)
+++ kolourpaint/BUGS	(.../branches/KDE/3.5/kdegraphics)	(wersja 734657)
@@ -62,17 +62,15 @@
 
 14. The text cursor may be momentarily misrendered when scrolling the view.
 
-16. The Edit/Paste option is not disabled when the clipboard data is lost
-    due to the owner terminating (no QClipboard::dataChanged() signal).
-
 17. a) Using KolourPaint on a remote X display may result in redraw errors
        and pixel data corruption.
 
     b) KolourPaint is screen depth dependent.  Opening an image with a
        an alpha channel and/or a depth higher than the screen and then
-       saving it will likely result in loss of colour information.  To
-       reduce data loss, run your screen at 24-bit.  This bug will be
-       addressed in a future version of KolourPaint.
+       saving it will likely result in loss of colour information.  Also,
+       8-bit screens are not supported at all.  To reduce data loss, run
+       your screen at 24-bit.  This bug will be addressed in a future
+       version of KolourPaint.
 
 19. Read support for EPS files is extremely slow.  You should not enable
     the "Save Preview" dialog when saving to EPS.  This is an issue with
Index: kolourpaint/tools/kptoolresizescale.cpp
===================================================================
--- kolourpaint/tools/kptoolresizescale.cpp	(.../tags/KDE/3.5.8/kdegraphics)	(wersja 734657)
+++ kolourpaint/tools/kptoolresizescale.cpp	(.../branches/KDE/3.5/kdegraphics)	(wersja 734657)
@@ -662,6 +662,7 @@
               "</ul>"
               "</qt>"));
 
+    // TODO: ALT+R doesn't select the button.
     m_resizeButton = new QToolButton (m_operationGroupBox);
     toolButtonSetLook (m_resizeButton,
                        QString::fromLatin1 ("resize"),
Index: kolourpaint/NEWS
===================================================================
--- kolourpaint/NEWS	(.../tags/KDE/3.5.8/kdegraphics)	(wersja 734657)
+++ kolourpaint/NEWS	(.../branches/KDE/3.5/kdegraphics)	(wersja 734657)
@@ -2,6 +2,11 @@
 KolourPaint 1.4_relight Series (branches/KDE/3.5/)
 ===============================
 
+KolourPaint 1.4.9_relight (Frozen ???)
+
+   * Ensure selection operations always repaint correctly
+     [the effects of this change are unlikely to be functionality visible]
+
 KolourPaint 1.4.8_relight (Frozen 2007-10-08)
 
    * Always enable the paste actions to guarantee that pasting from
Index: kolourpaint/kpmainwindow.cpp
===================================================================
--- kolourpaint/kpmainwindow.cpp	(.../tags/KDE/3.5.8/kdegraphics)	(wersja 734657)
+++ kolourpaint/kpmainwindow.cpp	(.../branches/KDE/3.5/kdegraphics)	(wersja 734657)
@@ -987,10 +987,20 @@
 void kpMainWindow::slotScrollViewAboutToScroll ()
 {
 #if DEBUG_KP_MAIN_WINDOW && 0
-    kdDebug () << "kpMainWindow::slotScrollViewAboutToScroll()" << endl;
-    kdDebug () << "\tfastUpdates=" << viewManager ()->fastUpdates ()
-               << " queueUpdates=" << viewManager ()->queueUpdates ()
-               << endl;
+    kdDebug () << "kpMainWindow::slotScrollViewAboutToScroll() tool="
+               << tool () << " viewManager=" << viewManager () << endl;
+    if (viewManager ())
+    {
+        kdDebug () << "\tfastUpdates=" << viewManager ()->fastUpdates ()
+                   << " queueUpdates=" << viewManager ()->queueUpdates ()
+                   << endl;
+    }
+    else
+    {
+        // We're getting a late signal from the scrollview (thanks to
+        // a timer inside the QScrollView).  By now, setDocument() has
+        // already killed the document(), tool() and viewManager().
+    }
 #endif
 
     QTimer::singleShot (0, this, SLOT (slotScrollViewAfterScroll ()));
Index: kolourpaint/pixmapfx/kppixmapfx.h
===================================================================
--- kolourpaint/pixmapfx/kppixmapfx.h	(.../tags/KDE/3.5.8/kdegraphics)	(wersja 734657)
+++ kolourpaint/pixmapfx/kppixmapfx.h	(.../branches/KDE/3.5/kdegraphics)	(wersja 734657)
@@ -93,6 +93,23 @@
     //
     // Converts <pixmap> to a QImage and returns it.
     //
+    // WARNING: On an 8-bit screen:
+    //
+    //              QPixmap result = convertToPixmap (convertToImage (pixmap));
+    //
+    //          <result> is slightly differently colored to <pixmap>.
+    //
+    //          KolourPaint needs to convert to QImage occasionally as
+    //          QImage allows KolourPaint to read pixels and because the QImage
+    //          methods give reliable results and pixel-identical results on
+    //          all platforms.  The QPixmap paint engine has no such guarantee
+    //          and even depends on the quality of the video driver.
+    //
+    //          As a result, KolourPaint should not be used on an 8-bit screen.
+    //          HITODO: Add warning on startup, like in KolourPaint/KDE4.
+    //
+    //          This bug will be fixed when KolourPaint gets a proper image library,
+    //          where QPixmap -> QImage -> QPixmap transitions will be not be needed.
     static QImage convertToImage (const QPixmap &pixmap);
 
     //
Index: kolourpaint/kpselectiontransparency.h
===================================================================
--- kolourpaint/kpselectiontransparency.h	(.../tags/KDE/3.5.8/kdegraphics)	(wersja 734657)
+++ kolourpaint/kpselectiontransparency.h	(.../branches/KDE/3.5/kdegraphics)	(wersja 734657)
@@ -39,10 +39,18 @@
     kpSelectionTransparency ();
     // Selection that's transparent at pixels with <color>
     kpSelectionTransparency (const kpColor &transparentColor, double colorSimilarity);
+    // If <isOpaque>, <transparentColor> is allowed to be anything
+    // (including invalid) as the color would have no effect.
+    // However, you are encouraged to set it as you would if !<isOpaque>,
+    // because setTransparent(true) might be called later, after which
+    // the <transparentColor> would suddenly become important.
+    //
+    // It is a similar case with <colorSimilarity>, although <colorSimilarity>
+    // must be in-range (see kpColorSimilarityDialog).
     kpSelectionTransparency (bool isOpaque, const kpColor &transparentColor, double colorSimilarity);
     // Returns whether they are visually equivalent.
     // This is the same as a memcmp() except that if they are both opaque,
-    // this function will return true regardless of the transaprentColor's.
+    // this function will return true regardless of the transparentColor's.
     bool operator== (const kpSelectionTransparency &rhs) const;
     bool operator!= (const kpSelectionTransparency &rhs) const;
     ~kpSelectionTransparency ();
@@ -52,6 +60,8 @@
     void setOpaque (bool yes = true);
     void setTransparent (bool yes = true);
 
+    // If isOpaque(), transparentColor() is generally not called because
+    // the transparent color would have no effect.
     kpColor transparentColor () const;
     void setTransparentColor (const kpColor &transparentColor);
 
Index: kolourpaint/kpviewscrollablecontainer.cpp
===================================================================
--- kolourpaint/kpviewscrollablecontainer.cpp	(.../tags/KDE/3.5.8/kdegraphics)	(wersja 734657)
+++ kolourpaint/kpviewscrollablecontainer.cpp	(.../branches/KDE/3.5/kdegraphics)	(wersja 734657)
@@ -389,6 +389,7 @@
 }
 
 
+// TODO: Are we checking for m_view == 0 often enough?
 kpViewScrollableContainer::kpViewScrollableContainer (kpMainWindow *parent,
                                                       const char *name)
     : QScrollView ((QWidget *) parent, name, Qt::WStaticContents | Qt::WNoAutoErase),
Index: kolourpaint/README
===================================================================
--- kolourpaint/README	(.../tags/KDE/3.5.8/kdegraphics)	(wersja 734657)
+++ kolourpaint/README	(.../branches/KDE/3.5/kdegraphics)	(wersja 734657)
@@ -1,5 +1,5 @@
 
-KolourPaint Version 1.4.8_relight (KDE 3.5.8 Release Frozen 2007-10-08)
+KolourPaint Version 1.4.9_relight (KDE 3.5.9 Release Frozen ???)
 http://www.kolourpaint.org/
 
 Copyright (c) 2003,2004,2005,2006 Clarence Dang <dang@kde.org>
Index: kolourpaint/kpselection.cpp
===================================================================
--- kolourpaint/kpselection.cpp	(.../tags/KDE/3.5.8/kdegraphics)	(wersja 734657)
+++ kolourpaint/kpselection.cpp	(.../branches/KDE/3.5/kdegraphics)	(wersja 734657)
@@ -545,14 +545,12 @@
     //       it's a border, not a text box) but saves memory when using
     //       that kpSelection::setPixmap (QPixmap ()) hack.
     m_pixmap = pixmap.isNull () ? 0 : new QPixmap (pixmap);
+    QRect changedRect = boundingRect ();
 
-    QRect oldRect = boundingRect ();
-    emit changed (oldRect);
-
     if (m_pixmap)
     {
-        const bool changedSize = (m_pixmap->width () != oldRect.width () ||
-                                  m_pixmap->height () != oldRect.height ());
+        const bool changedSize = (m_pixmap->width () != m_rect.width () ||
+                                  m_pixmap->height () != m_rect.height ());
         const bool changedFromText = (m_type == Text);
         if (changedSize || changedFromText)
         {
@@ -560,8 +558,8 @@
             {
                 kdError () << "kpSelection::setPixmap() changes the size of the selection!"
                         << "   old:"
-                        << " w=" << oldRect.width ()
-                        << " h=" << oldRect.height ()
+                        << " w=" << m_rect.width ()
+                        << " h=" << m_rect.height ()
                         << "   new:"
                         << " w=" << m_pixmap->width ()
                         << " h=" << m_pixmap->height ()
@@ -580,11 +578,13 @@
 
             m_textLines = QValueVector <QString> ();
 
-            emit changed (boundingRect ());
+            changedRect = changedRect.unite (boundingRect ());
         }
     }
 
     calculateTransparencyMask ();
+
+    emit changed (changedRect);
 }
 
 
Index: kmrml/kmrml/kcontrol/kcmkmrml.desktop
===================================================================
--- kmrml/kmrml/kcontrol/kcmkmrml.desktop	(.../tags/KDE/3.5.8/kdegraphics)	(wersja 734657)
+++ kmrml/kmrml/kcontrol/kcmkmrml.desktop	(.../branches/KDE/3.5/kdegraphics)	(wersja 734657)
@@ -18,6 +18,7 @@
 Name[da]=Billedindeks
 Name[de]=Bildindex
 Name[el]=Ευρετήριο εικόνων
+Name[eo]=Bildindekso
 Name[es]=Índice de imágenes
 Name[et]=Pildiindeks
 Name[eu]=Irudiaren indizea
Index: kmrml/kmrml/mrml-servicemenu.desktop
===================================================================
--- kmrml/kmrml/mrml-servicemenu.desktop	(.../tags/KDE/3.5.8/kdegraphics)	(wersja 734657)
+++ kmrml/kmrml/mrml-servicemenu.desktop	(.../branches/KDE/3.5/kdegraphics)	(wersja 734657)
@@ -14,6 +14,7 @@
 Name[da]=Søg efter lignende filer...
 Name[de]=Nach ähnlichen Bildern suchen ...
 Name[el]=Αναζήτηση για παρόμοιες εικόνες...
+Name[eo]=Serĉi Similajn Bildojn...
 Name[es]=Búsqueda de imágenes similares...
 Name[et]=Otsi sarnaseid pilte...
 Name[eu]=Bilatu antzeko irudiak...
@@ -31,11 +32,11 @@
 Name[km]=ស្វែងរក​រូបភាព​ស្រដៀង​គ្នា...
 Name[lt]=Panašių paveikslėlių paieška...
 Name[ms]=Cari Imej Serupa...
-Name[nb]=Søk etter liknende bilder ...
+Name[nb]=Søk etter liknende bilder …
 Name[nds]=Na lieke Biller söken...
 Name[ne]=उस्तै छविका लागि खोजी गर्नुहोस्...
 Name[nl]=Zoeken naar vergelijkbare afbeeldingen...
-Name[nn]=Søk etter liknande bilete ...
+Name[nn]=Søk etter liknande bilete …
 Name[nso]=Nyako ya Diponagalo tseo di Swanago...
 Name[pl]=Szukaj podobnych obrazków
 Name[pt]=Procurar por Imagens Semelhantes...
Index: kmrml/kmrml/mrml_part.desktop
===================================================================
--- kmrml/kmrml/mrml_part.desktop	(.../tags/KDE/3.5.8/kdegraphics)	(wersja 734657)
+++ kmrml/kmrml/mrml_part.desktop	(.../branches/KDE/3.5/kdegraphics)	(wersja 734657)
@@ -10,6 +10,7 @@
 Name[da]=MRML-visning
 Name[de]=MRML-Ansicht
 Name[el]=Προβολή MRML
+Name[eo]=MRML-Rigardo
 Name[es]=Vista de MRML
 Name[et]=MRML vaade
 Name[eu]=MRML ikuspegia
Index: kfile-plugins/ps/gsthumbnail.desktop
===================================================================
--- kfile-plugins/ps/gsthumbnail.desktop	(.../tags/KDE/3.5.8/kdegraphics)	(wersja 734657)
+++ kfile-plugins/ps/gsthumbnail.desktop	(.../branches/KDE/3.5/kdegraphics)	(wersja 734657)
@@ -11,6 +11,7 @@
 Name[da]=PostScript, PDF- og DVI-filer
 Name[de]=PostScript-, PDF- und DVI-Dateien
 Name[el]=Αρχεία PostScript, PDF και DVI
+Name[eo]=Postskriptaj, PDF- kaj DVI-dosieroj
 Name[es]=Archivos PostScript, PDF y DVI
 Name[et]=PostScript-, PDF- ja DVI-failid
 Name[eu]=PostScript, PDF eta DVI fitxategiak
Index: kfile-plugins/dvi/kfile_dvi.desktop
===================================================================
--- kfile-plugins/dvi/kfile_dvi.desktop	(.../tags/KDE/3.5.8/kdegraphics)	(wersja 734657)
+++ kfile-plugins/dvi/kfile_dvi.desktop	(.../branches/KDE/3.5/kdegraphics)	(wersja 734657)
@@ -11,6 +11,7 @@
 Name[da]=DVI-info
 Name[de]=DVI-Info
 Name[el]=Πληροφορίες DVI
+Name[eo]=DVI-informo
 Name[es]=Info DVI
 Name[et]=DVI info
 Name[fa]=اطلاعات DVI
Index: kfile-plugins/pnm/kfile_pnm.desktop
===================================================================
--- kfile-plugins/pnm/kfile_pnm.desktop	(.../tags/KDE/3.5.8/kdegraphics)	(wersja 734657)
+++ kfile-plugins/pnm/kfile_pnm.desktop	(.../branches/KDE/3.5/kdegraphics)	(wersja 734657)
@@ -10,6 +10,7 @@
 Name[da]=PNG-info
 Name[de]=PNM-Info
 Name[el]=Πληροφορίες PNM
+Name[eo]=PNM-informo
 Name[es]=Info PNM
 Name[et]=PNM info
 Name[fa]=اطلاعات PNM
Index: kfile-plugins/pcx/kfile_pcx.desktop
===================================================================
--- kfile-plugins/pcx/kfile_pcx.desktop	(.../tags/KDE/3.5.8/kdegraphics)	(wersja 734657)
+++ kfile-plugins/pcx/kfile_pcx.desktop	(.../branches/KDE/3.5/kdegraphics)	(wersja 734657)
@@ -11,6 +11,7 @@
 Name[da]=PCX Fil-meta-info
 Name[de]=PCX Metainformation
 Name[el]=Μετα-πληροφορίες αρχείου PCX
+Name[eo]=PCX-dosiera metainformo
 Name[es]=Info meta de archivos PCX
 Name[et]=PCX faili metainfo
 Name[eu]=PCX fitxategi meta info
Index: kfile-plugins/exr/kfile_exr.desktop
===================================================================
--- kfile-plugins/exr/kfile_exr.desktop	(.../tags/KDE/3.5.8/kdegraphics)	(wersja 734657)
+++ kfile-plugins/exr/kfile_exr.desktop	(.../branches/KDE/3.5/kdegraphics)	(wersja 734657)
@@ -9,6 +9,7 @@
 Name[da]=EXR-Info
 Name[de]=EXR-Info
 Name[el]=Πληροφορίες EXR
+Name[eo]=EXR-informo
 Name[es]=Info EXR
 Name[et]=EXR info
 Name[fa]=اطلاعات EXR
Index: kfile-plugins/xpm/kfile_xpm.desktop
===================================================================
--- kfile-plugins/xpm/kfile_xpm.desktop	(.../tags/KDE/3.5.8/kdegraphics)	(wersja 734657)
+++ kfile-plugins/xpm/kfile_xpm.desktop	(.../branches/KDE/3.5/kdegraphics)	(wersja 734657)
@@ -7,6 +7,7 @@
 Name[cs]=XPM info
 Name[de]=XPM-Info
 Name[el]=Πληροφορίες XPM
+Name[eo]=XPM-informo
 Name[es]=Información XPM
 Name[et]=XPM info
 Name[fa]=اطلاعات XPM
Index: kfile-plugins/dds/kfile_dds.desktop
===================================================================
--- kfile-plugins/dds/kfile_dds.desktop	(.../tags/KDE/3.5.8/kdegraphics)	(wersja 734657)
+++ kfile-plugins/dds/kfile_dds.desktop	(.../branches/KDE/3.5/kdegraphics)	(wersja 734657)
@@ -7,6 +7,7 @@
 Name[da]=DirectDraw overflade-info
 Name[de]=DirectDraw Oberflächeninfo
 Name[el]=Πληροφορίες επιφάνειας DirectDraw
+Name[eo]=DirectDraw surfac-informo
 Name[es]=Información de la primera vista de DirectDraw
 Name[et]=DirectDraw Surface'i info
 Name[eu]=DirectDraw Surface informazioa

Zmiany atrybutów dla: .
___________________________________________________________________
Nazwa: svn:externals
   + admin https://svn.kde.org/home/kde/branches/KDE/3.5/kde-common/admin


